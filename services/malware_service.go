package services

import (
	"archive/zip"
	"bufio"
	"bytes"
	"errors"
	"strings"
	"sync"
	"time"

	"github.com/go-kit/log/level"
	"github.com/go-resty/resty/v2"
	"github.com/mailio/go-mailio-server/global"
)

type MalwareService struct {
	restClient  *resty.Client
	baseUrl     string
	path        string
	malwareMd5s map[string]bool
	// lock for malwaremd5 hash
	md5RWMutex sync.RWMutex
}

// NewMalwareService loads the malware list from the abuse.ch website
func NewMalwareService() *MalwareService {

	// https://bazaar.abuse.ch/export/txt/md5/full/

	client := resty.New().SetBaseURL("https://bazaar.abuse.ch").SetHeader("Accept", "application/zip").
		// Set default headers (customize as per your requirement)
		SetHeaders(map[string]string{
			"User-Agent":      "Go-Resty-Client",
			"Accept":          "application/zip",
			"Accept-Encoding": "gzip",
		}).
		// Set retry count and wait time between retries
		SetRetryCount(3).
		SetRetryWaitTime(2 * time.Second).
		SetRetryMaxWaitTime(10 * time.Second).
		// Enable logging of requests and responses
		SetDebug(false).
		// Set timeout for the request
		SetTimeout(30 * time.Second)

	return &MalwareService{
		restClient:  client,
		baseUrl:     "https://bazaar.abuse.ch",
		path:        "/export/txt/md5/full/",
		malwareMd5s: make(map[string]bool)}
}

// LoadInMemoryMalwareList loads the malware list from the abuse.ch website
func (ms *MalwareService) LoadInMemoryMalwareList() error {
	resp, err := ms.restClient.R().Get(ms.path)
	if err != nil {
		level.Error(global.Logger).Log("error while fetching malware list", err)

		return err
	}
	if resp.IsError() {
		level.Error(global.Logger).Log("error while fetching malware list", resp.Error())
		return errors.New("error while fetching malware list")
	}

	// Unzip the file in memory
	zipReader, err := zip.NewReader(bytes.NewReader(resp.Body()), int64(len(resp.Body())))
	if err != nil {
		level.Error(global.Logger).Log("error while unzipping the malware file", err)
		return errors.New("error while unzipping the malware file")
	}
	// Loop through the files in the ZIP
	ms.md5RWMutex.Lock()         // Acquire write lock
	defer ms.md5RWMutex.Unlock() // Release write lock

	for _, file := range zipReader.File {
		if strings.HasSuffix(file.Name, ".txt") {
			// Open the file inside the ZIP archive
			txtFile, err := file.Open()
			if err != nil {
				level.Error(global.Logger).Log("error while opening the malware file", err)
				return errors.New("error while opening the malware file")
			}
			defer txtFile.Close()
			// Read CSV content
			fileScanner := bufio.NewScanner(txtFile)
			for fileScanner.Scan() {
				line := fileScanner.Text()
				// Skip lines starting with '#'
				if strings.HasPrefix(line, "#") {
					continue
				}

				// Process each valid line (which represents an MD5 in your case)
				ms.malwareMd5s[line] = true
			}

			if err := fileScanner.Err(); err != nil {
				level.Error(global.Logger).Log("error while reading malware TXT file", err)
				return errors.New("error while reading malware TXT file")
			}
		}
	}

	return nil
}

// IsMalware checks if the given md5 is in the malware list
func (ms *MalwareService) IsMalware(md5 string) bool {
	// Check if the md5 is in the malware list
	ms.md5RWMutex.RLock()         // Acquire read lock
	defer ms.md5RWMutex.RUnlock() // Release read lock

	_, ok := ms.malwareMd5s[md5]
	return ok
}
